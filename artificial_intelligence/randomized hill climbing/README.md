# Probabilistic Search Algorithms: Implementing and Experimenting with Randomized Hill Climbing (RHC)

Implemented Randomized Hill Climbing and applied it to a minimization problem involving the following function _f_:

_f(x,y) = [1 + (x + y +1)2(19 - 14x + 3x2 -14y + 6xy +3y2)][30 + (2x - 3y)2(18 -32x + 12x2 + 4y - 36xy + 27y2)]_, where _-2 ≤ x,y ≤ 2_

Procedure has the following input parameters:
 - _sp_: is the starting point of the Randomized Hill Climbing run
 - _p_ the number of neighbors of the current solution that will be generated
 - _z_ neighborhood size; for example if _z_ is set to _z=0.5_, the _p_ neighbors for the current solution _s_ are generated by adding vectors _v=(z1,z2)_ with _z1_ and _z2_ being random numbers in [-0.5, +0.5] uniformly distributed 
 - seed which is an integer that will be used as the seed for the random generator you employ in your implementation. 

RHC returns a vector _(x,y)_ with the value of _f(x,y)_ and the number solutions that were generated during the run of RHC.

Ran the randomized hill climbing procedure RHC twice for the following parameters:
sp = (0.4, -0.5), (-0.5, 0.3), (1, -2) and (0,0)
p = 30 and 120
z = 0.03 and 0.1


**SUMMARY**

First it is imperative to find the proper solution in order to evaluate the solutions. Solving for _f(x,y)_ reveals that the proper minimization has _x = -0.6, y = -0.4_, and _f(x,y) = 30_. 

Next we define what is solution quality and algorithm speed. Therefore, the closer the results are to the proper minimization values, the higher the quality. Likewise, the smaller the number of solutions searched, the faster the speed is. Assessing the performance of RHC will be based on what the user would want. For higher quality solutions, the user should use parameters with more _p_ neighbors and a smaller _z_ neighbor hood size, as the heuristic would search for a better quality solution over a larger area with more precise points. For faster speeds, the user should use parameters with less _p_ neighbors and a larger _z_ neighbor hood size, as the heuristic would search for a faster solution over a smaller area with less precise points. This makes sense in terms of computing cost paradigms, as one would usually have to sacrifice speed in favor of precision or vice versa. 

In conclusion, RHC can be good at finding local minima depending on the “landscape” of the function. Also, a good advantage that RHC has is the ability of the user to tweak its parameters according to the function (high adaptability). However, if the function’s landscape has many steep ridges and alleys, then the heuristic can take much longer to find the goal state as it would have to zig-zag back and forth horizontally a bunch of times to traverse vertically. Plateaus can be another challenge, as the heuristic could get stuck in finding its goal state due to the limited machine precision of a point’s neighbors (such as if a goal state appears to be numerically equal to its neighbors). 